import { Sortable, MultiDrag } from 'sortablejs';

Sortable.mount(new MultiDrag());

window.Vaadin.Flow.sortableConnector = {
    initLazy: function (customConfig, c, layout) {
        // Check whether the connector was already initialized
        if (c.$connector) {
            return;
        }

        c.$connector = {
            //// functions
            setOption : function(optionName, optionValue) {
                this.sortable.options[optionName] = optionValue;
            },

            clearClone : function() {
                this.clonedElements.forEach(clone => {
                    if (clone.parentNode) {
                        clone.parentNode.removeChild(clone);
                    }
                });
                this.clonedElements = [];
            },

            moveElement : function(index, direction) {
                c.$connector.focusedElement = document.activeElement;
                if (["up", "down"].includes(direction) == false ) {
                    return false
                }
                const sortable = c.$connector.sortable;

                let order = sortable.toArray();
                const sortableId = order[index];
                // pull the item we're moving out of the order
                order.splice(index, 1)

                let newIndex;
                // put it back in at the correct position
                if (direction == 'down') {
                    newIndex = index+1;
                } else if (direction == 'up') {
                    newIndex = index-1;
                }
                order.splice(newIndex, 0, sortableId);
                sortable.sort(order, true);
            }
            ,
            refocus() {
                if (c.$connector.focusedElement !== undefined) {
                    c.$connector.focusedElement.focus();
                }
                c.$connector.focusedElement = undefined;
            }
        };

        c.$connector.sortable = Sortable.create(layout, customConfig);

        c.$connector.clonedElements = [];

        c.$connector.sortable.options.onEnd = function (/**Event*/evt) {
            let oldIndexes = [evt.oldIndex];
            let newIndexes = [evt.newIndex];
            if (evt.newIndicies && evt.oldIndicies && evt.newIndicies.length > 0) {
                newIndexes = evt.newIndicies.map(newIndex => newIndex.index);
                oldIndexes = evt.oldIndicies.map(oldIndex => oldIndex.index);
            }
            if (evt.to === evt.from) {
                c.$server.onReorderListener(oldIndexes, newIndexes);
            } else {
                const clone = (evt.pullMode === 'clone');
                evt.from.parentElement.$server.onRemoveListener(oldIndexes, clone);
                evt.to.parentElement.$server.onAddListener(newIndexes, clone);
                if (clone) {
                    // store the clone(s) generated by the client-side
                    // and delete later (to avoid the element to disappear/reappear)
                    if (evt.clone) {
                        c.$connector.clonedElements = [evt.clone];
                    } else {
                        c.$connector.clonedElements = [...evt.clones];
                    }
                }

            }
        }


        c.$connector.sortable.options.onChoose = function (/**Event*/evt) {
            c.dispatchEvent(new CustomEvent('on-choose'));
        }

        c.$connector.sortable.options.onUnchoose = function (/**Event*/evt) {
            c.dispatchEvent(new CustomEvent('on-unchoose'));
        }
        c.$connector.sortable.options.onChange = function (/**Event*/evt) {
            c.dispatchEvent(new CustomEvent('on-change'));
        }
    }
}